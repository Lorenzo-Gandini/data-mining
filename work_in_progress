Data mining project

Spezzato in 3 il singolo trip.
1 - Città
2 - Merci 
3 - Quantità

Città
Jaccard similarity (JS) svolta sulle città in cui passa il camion.
Abbiamo deciso di penalizzare di più un camionista che fa di testa sua completamente rispetto ad un autista che effettua le soste nelle città predefinite seppur in ordine sparso. 
Il risualtato della Jaccard Similarity è compreso tra 0 e 1, essendo per definizione : intersezione/unione. 
Ma nel nostro caso abbiamo deciso di prendere come valore la distanza, per questo motivo il valore "ritornato" è : 1 - JS, Perciò: 
JS = 1 ? ---> Jaccard_Distance = 0 (Le due route distano 0 tra loro --> sono identiche)
JS = 0 ? ---> Jaccard_Distance = 1 (Le due route distano 1 tra loro --> sono completamente diverse)

--------------------------------------------------------------------------------------------------------------------------------
Merci

Utilizzato One Hot Encoding per codificare le diverse merci.
Una volta codificate tutte le merci, effettuata la Hamming distance sulle diverse “righe”, in caso di liste di lunghezza diverse (omessi o aggiunti prodotti), viene aggiunta una lista di (n) 0, in modo da computare la Hamm_dist tra le righe extra e la riga di 0, dove il valore sarà = al numero di bit a 1.
Per fare ciò vengono eseguiti uno xor e un or ad ogni operazione per definire l'unione (OR) e la distanza (XOR)
- Esempio :

    S0 "merchandise": {"Oranges","Corn","Plums"} è       [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]
    A0 "merchandise": {"Oranges","Corn","Plums",Basil} è [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]
    
    L'unione è data dall'operazione OR, la quale ritorna "True" ogni volta che almeno uno dei valori è settato a "True" oppure 1, l'OR delle due codifiche binarie restituisce 4.

    La distanza è data invece dall'operaione XOR, la quale ritorna "True" ogni volta che i valori sono diversi, nel nosro caso, l'unica differenza è data dal confronto dell'ultimo bit delle due codifiche (0 e 1), lo XOR restituisce infatti 1. 

    Abbiamo aggiunto l'OR alla classica operazione di Hamming distance, così da avere un risultato

--------------------------------------------------------------------------------------------------------------------------------
Quantità

Utilizzato lo stesso concetto del one hot encoding. In caso un prodotto sia presente in entrambe le liste andiamo a eseguire la differenza tra i due (in valore assoluto per evitare valori negativi).
Così facendo otteniamo un valore n che più è grande più indica differenza tra i valori, facciamo questo per ogni merce e sommiamo i valori insieme (1).
Noi però desideriamo un valore tra 0 e 1 per essere simile al valore dei primi due (Jaccard e Hamming distances). 
Per andare quindi ad ottenere la Quantity_distance "normalizzata" sommiamo tra loro i numeri più grandi in ogni confronto(2) e poi dividiamo la somma (1) per la somma (2). 
- Esempio :

    S_0 : Oranges : 5, Milk : 10, Bread : 10
    A_0 : Oranges : 5, Milk : 20, Water : 4

    In questo caso, nella distanza verrebbero considerati Oranges e Milk, perchè elementi comuni -->(Water e Bread non sono elementi comuni). Stabiliti gli elementi coinvolti iniziamo a fare le differenze.
    Oranges 5 - Oranges 5 = 0 (numero più alto --> 5) ---- Milk 20 - Milk 10 = 10 (Numero più alto --> 20) , quindi:
    Distanza totale = 0/5 + 10/20 = 0.5
    oppure ----> (?) Decidere poi.
    Distanza totale = 0+10 / 20+5 = 10 / 25 = 0.4
Prima perplessità, ma così facendo non verrebbe ignorato il fatto che nelle tratte vengono portati oggetti diversi? 
Si ... ma, no. Il motivo per cui la risposta finale è no è perchè in realtà ciò è già considerato nel calcolo della Hamming distance, alla quale è attribuito un peso (weight) maggiore e quindi va già a penalizzare il punteggio finale.

--------------------------------------------------------------------------------------------------------------------------------
Realizzare nuove standard route per la compagnia.

Per generare le nuove standard route, abbiamo deciso di prendere le actual route generate fino ad oggi dai vari autisti e di comparare tra loro tutte le actual route generate da una stessa standard route. Così facendo otterremmo la actual route più simile a tutte le actual route generate fino ad ora. Questa actual route diventerà la nuova standard route. Aggiunto un check finale, qualora la standard route risultasse come il miglior fit (ovvero risulta come il percorso con meno differenza tra tutti i vari percorsi), lo standard suggerito risulterebbe lo standard originale.

--------------------------------------------------------------------------------------------------------------------------------
Classifica Drivers

Per generare la lista contenente la classifica dei driver con le conseguenti standard route, abbiamo utilizzato la similarity function da noi creata all'inizio. 
Per utilizzarla, abbiamo comparato ogni singola actual route ad ogni singola standard route, non solo con le standard route iniziali, ma anche con le standard route da noi create nel primo punto. Salvando per ogni confronto il punteggio, nel farlo abbiamo confrontato actual routes con standard routes diverse dalle standard route da cui sono state generate le actual route.
Esempio:
    Il driver C è associato alla route A0, le S0,S1. A0 è basata su S0.
    Nei confronti compariamo S0 con A0 e poi pure S1 con A0, perchè, magari, 
    A0 ha una similarità maggiore con S1 piuttosto che S0. ----> Quindi la lista vedrebbe {"driver" : C, "route" : [S1,S0]}

--------------------------------------------------------------------------------------------------------------------------------
Punto 3.

Stiamo ancora facendo prove testando cose diverse...
Ad oggi stiamo provando a generare "from scratch" le routes ideali per ogni driver. La lunghezza è basata sul numero di trips effettuati in media dai diversi driver ogni volta che eseguono una route.



